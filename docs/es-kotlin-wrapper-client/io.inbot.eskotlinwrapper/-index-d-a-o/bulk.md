[es-kotlin-wrapper-client](../../index.md) / [io.inbot.eskotlinwrapper](../index.md) / [IndexDAO](index.md) / [bulk](./bulk.md)

# bulk

`fun bulk(bulkSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 100, retryConflictingUpdates: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)` = 0, refreshPolicy: RefreshPolicy = WriteRequest.RefreshPolicy.WAIT_UNTIL, itemCallback: ((`[`BulkOperation`](../-bulk-operation/index.md)`<`[`T`](index.md#T)`>, BulkItemResponse) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`)? = null, operationsBlock: `[`BulkIndexingSession`](../-bulk-indexing-session/index.md)`<`[`T`](index.md#T)`>.(session: `[`BulkIndexingSession`](../-bulk-indexing-session/index.md)`<`[`T`](index.md#T)`>) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)

Create a [BulkIndexingSession](../-bulk-indexing-session/index.md) and use it with the [operationsBlock](bulk.md#io.inbot.eskotlinwrapper.IndexDAO$bulk(kotlin.Int, kotlin.Int, org.elasticsearch.action.support.WriteRequest.RefreshPolicy, kotlin.Function2((io.inbot.eskotlinwrapper.BulkOperation((io.inbot.eskotlinwrapper.IndexDAO.T)), org.elasticsearch.action.bulk.BulkItemResponse, kotlin.Unit)), kotlin.Function2((io.inbot.eskotlinwrapper.BulkIndexingSession((io.inbot.eskotlinwrapper.IndexDAO.T)), , kotlin.Unit)))/operationsBlock). Inside the block you can call operations
like `index` and other functions exposed by [BulkIndexingSession](../-bulk-indexing-session/index.md). The resulting bulk
operations are automatically grouped in bulk requests of size [bulkSize](bulk.md#io.inbot.eskotlinwrapper.IndexDAO$bulk(kotlin.Int, kotlin.Int, org.elasticsearch.action.support.WriteRequest.RefreshPolicy, kotlin.Function2((io.inbot.eskotlinwrapper.BulkOperation((io.inbot.eskotlinwrapper.IndexDAO.T)), org.elasticsearch.action.bulk.BulkItemResponse, kotlin.Unit)), kotlin.Function2((io.inbot.eskotlinwrapper.BulkIndexingSession((io.inbot.eskotlinwrapper.IndexDAO.T)), , kotlin.Unit)))/bulkSize) and sent off to Elasticsearch. For each
operation there will be a call to the [itemCallback](bulk.md#io.inbot.eskotlinwrapper.IndexDAO$bulk(kotlin.Int, kotlin.Int, org.elasticsearch.action.support.WriteRequest.RefreshPolicy, kotlin.Function2((io.inbot.eskotlinwrapper.BulkOperation((io.inbot.eskotlinwrapper.IndexDAO.T)), org.elasticsearch.action.bulk.BulkItemResponse, kotlin.Unit)), kotlin.Function2((io.inbot.eskotlinwrapper.BulkIndexingSession((io.inbot.eskotlinwrapper.IndexDAO.T)), , kotlin.Unit)))/itemCallback). This allows you to keep track of failures, do logging,
or implement retries. If you leave this `null`, the default callback implementation defined in
[BulkIndexingSession](../-bulk-indexing-session/index.md) is used.

See [BulkIndexingSession](../-bulk-indexing-session/index.md) for the meaning of the other parameters.

